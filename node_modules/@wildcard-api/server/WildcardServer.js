"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WildcardServer = void 0;
// @ts-ignore
const json_s_1 = require("@brillout/json-s");
const autoLoadEndpointFiles_1 = require("./autoLoadEndpointFiles");
const assert_1 = require("@brillout/assert");
// @ts-ignore
const getUrlProps = require("@brillout/url-props");
loadTimeStuff();
const HttpRequestMethod = ["POST", "GET", "post", "get"];
const configDefault = {
    disableCache: false,
    baseUrl: "/_wildcard_api/",
};
class WildcardServer {
    constructor() {
        this.endpoints = getEndpointsProxy();
        this.config = getConfigProxy(configDefault);
    }
    /**
     * Get the HTTP response of API HTTP requests. Use this if you cannot use the express/koa/hapi middleware.
     * @param requestProps.url HTTP request URL
     * @param requestProps.method HTTP request method
     * @param requestProps.body HTTP request body
     * @param context The context object - the endpoint functions' `this`.
     * @returns HTTP response
     */
    async getApiHttpResponse(requestProps, context, 
    /** @ignore */
    { __INTERNAL_universalAdapter, } = {}) {
        try {
            return await _getApiHttpResponse(requestProps, context, this.endpoints, this.config, __INTERNAL_universalAdapter);
        }
        catch (internalError) {
            // There is a bug in the Wildcard source code
            return handleInternalError(internalError);
        }
    }
    /** @private */
    async __directCall(endpointName, endpointArgs, context) {
        return await directCall(endpointName, endpointArgs, context, this.endpoints);
    }
}
exports.WildcardServer = WildcardServer;
async function _getApiHttpResponse(requestProps, context, endpoints, config, universalAdapterName) {
    try {
        context = await getContext(context);
    }
    catch (contextError) {
        return handleContextError(contextError);
    }
    assert_1.assert(context === undefined || context instanceof Object);
    const wrongApiUsage = validateApiUsage(requestProps, universalAdapterName);
    if (wrongApiUsage) {
        return handleWrongApiUsage(wrongApiUsage);
    }
    const { endpointName, endpointArgs, malformedRequest, malformedIntegration, isNotWildcardRequest, isHumanMode, } = parseRequestInfo(requestProps, endpoints, config, universalAdapterName);
    if (isNotWildcardRequest) {
        return null;
    }
    if (malformedRequest) {
        return handleMalformedRequest(malformedRequest);
    }
    if (malformedIntegration) {
        return handleMalformedIntegration(malformedIntegration);
    }
    if (!endpointName || !endpointArgs) {
        assert_1.assert(false);
        // Make TS happy
        throw new Error();
    }
    const { endpointResult, endpointError } = await runEndpoint(endpointName, endpointArgs, context, false, endpoints, universalAdapterName);
    return handleEndpointOutcome(endpointResult, endpointError, isHumanMode, endpointName, config);
}
async function directCall(endpointName, endpointArgs, context, endpoints) {
    assert_1.assert(endpointName);
    assert_1.assert(endpointArgs.constructor === Array);
    if (noEndpoints(endpoints)) {
        autoLoadEndpointFiles_1.autoLoadEndpointFiles();
    }
    assert_1.assertUsage(doesEndpointExist(endpointName, endpoints), getEndpointMissingText(endpointName, endpoints).join(" "));
    const resultObject = await runEndpoint(endpointName, endpointArgs, context, true, endpoints, undefined);
    const { endpointResult, endpointError } = resultObject;
    if (endpointError) {
        throw endpointError;
    }
    else {
        return endpointResult;
    }
}
async function runEndpoint(endpointName, endpointArgs, context, isDirectCall, endpoints, universalAdapterName) {
    assert_1.assert(endpointName);
    assert_1.assert(endpointArgs.constructor === Array);
    assert_1.assert([true, false].includes(isDirectCall));
    const endpoint = endpoints[endpointName];
    assert_1.assert(endpoint);
    assert_1.assert(endpointIsValid(endpoint));
    const contextProxy = createContextProxy(context, endpointName, isDirectCall, universalAdapterName);
    assert_1.assert(contextProxy !== undefined);
    assert_1.assert(contextProxy instanceof Object);
    let endpointResult;
    let endpointError;
    try {
        endpointResult = await endpoint.apply(contextProxy, endpointArgs);
    }
    catch (err) {
        endpointError = err;
    }
    return { endpointResult, endpointError };
}
function endpointIsValid(endpoint) {
    return isCallable(endpoint) && !isArrowFunction(endpoint);
}
function validateEndpoint(obj, prop, value) {
    const endpointName = prop;
    const endpointFunction = value;
    assert_1.assertUsage(isCallable(endpointFunction), [
        "An endpoint must be a function,",
        `but the endpoint \`${endpointName}\` is`,
        endpointFunction && endpointFunction.constructor
            ? `a \`${endpointFunction.constructor.name}\``
            : "`" + endpointFunction + "`",
    ].join(" "));
    assert_1.assertUsage(!isArrowFunction(endpointFunction), [
        "The endpoint function `" + endpointName + "` is an arrow function.",
        "Endpoints cannot be defined with arrow functions (`() => {}`),",
        "use a plain function (`function(){}`) instead.",
    ].join(" "));
    assert_1.assert(endpointIsValid(endpointFunction));
    obj[prop] = value;
    return true;
}
function isCallable(thing) {
    return thing instanceof Function || typeof thing === "function";
}
function isArrowFunction(fn) {
    // https://stackoverflow.com/questions/28222228/javascript-es6-test-for-arrow-function-built-in-function-regular-function
    // https://gist.github.com/brillout/51da4cb90a5034e503bc2617070cfbde
    assert_1.assert(!yes(function () { }));
    assert_1.assert(yes(() => { }));
    assert_1.assert(!yes(async function () { }));
    assert_1.assert(yes(async () => { }));
    return yes(fn);
    function yes(fn) {
        // This (unfortunately...) seems to be the most reliable way.
        return typeof fn === "function" && /^[^{]+?=>/.test(fn.toString());
    }
}
function isHumanReadableMode(method) {
    const DEBUG_CACHE = 
    /*/
  true
  /*/
    false;
    //*/
    assert_1.assert(method && method.toUpperCase() === method);
    if (DEBUG_CACHE) {
        return false;
    }
    if (method === "GET") {
        return true;
    }
    else {
        return false;
    }
}
function makeHumanReadable(responseProps, endpointResult) {
    const text = responseProps.contentType === "application/json"
        ? JSON.stringify(endpointResult && endpointResult instanceof Object
            ? endpointResult
            : JSON.parse(responseProps.body), null, 2)
        : responseProps.body;
    return get_html_response(`<h1>API Response</h1>
<pre>
${text}
</pre>
<br/>
<br/>
Status code: <b>${responseProps.statusCode}</b>
`);
}
function get_html_response(htmlBody) {
    const note = "Showing HTML because the request's method is <code>GET</code>. Make a <code>POST</code> request to get JSON.";
    let body = `<html><body>
<style>
  code {
    display: inline-block;
    padding: 0px 2px 1px 3px;
    font-size: 0.98em;
    border: 1px solid #d8d8d8;
    border-radius: 3px;
    background: #f5f5f5;
  }
  small {
    color: #777;
  }
</style>
${htmlBody}
`;
    body += `
<br/>
<br/>
<small>
${note.split("\n").join("<br/>\n")}
</small>
`;
    body += `
</body></html>
`;
    const responseProps = {
        body,
        contentType: "text/html",
        statusCode: 200,
    };
    return responseProps;
}
function getEndpointsProxy() {
    const Endpoints = {};
    return new Proxy(Endpoints, { set: validateEndpoint });
}
function getConfigProxy(configDefaults) {
    const configObject = Object.assign({}, configDefaults);
    const configProxy = new Proxy(configObject, { set: validateConfig });
    return configProxy;
    function validateConfig(_, configName, configValue) {
        assert_1.assertUsage(configName in configDefaults, [
            `Unknown config \`${configName}\`.`,
            "Make sure that the config is a `@wildcard-api/server` config",
            "and not a `@wildcard-api/client` one.",
        ].join(" "));
        configObject[configName] = configValue;
        return true;
    }
}
function createContextProxy(context, endpointName, isDirectCall, universalAdapterName) {
    let contextObject = context || {};
    const contextProxy = new Proxy(context || {}, { get, set });
    return contextProxy;
    function set() {
        assert_1.assertUsage(false, "The context object cannot be modified.");
        // Make TS happy
        return false;
    }
    function get(_, contextProp) {
        assert_1.assertUsage(context, getContextUsageNote(endpointName, contextProp, isDirectCall, universalAdapterName));
        return contextObject[contextProp];
    }
}
function getContextUsageNote(endpointName, prop, isDirectCall, universalAdapterName) {
    const common = [
        `Your endpoint function \`${endpointName}\` is trying to get \`this.${prop}\`,`,
        "but you didn't define any context and",
        "as a result `this` is `undefined`.",
        `Make sure to provide a context`,
    ].join(" ");
    if (!isDirectCall) {
        const contextSource = universalAdapterName
            ? `with the \`setContext\` function when using the \`wildcard(setContext)\` ${universalAdapterName} middleware.`
            : "when using `getApiHttpResponse(requestProps, context)`.";
        return [common, contextSource].join(" ");
    }
    assert_1.assert(isDirectCall);
    assert_1.assert(universalAdapterName === undefined);
    return [
        "Wrong usage of the Wildcard client in Node.js.",
        common,
        `by using \`bind({${prop}})\` when calling your \`${endpointName}\` endpoint in Node.js.`,
        "More infos at https://github.com/reframejs/wildcard-api/blob/master/docs/ssr-auth.md",
    ].join(" ");
}
function parseRequestInfo(requestProps, endpoints, config, universalAdapterName) {
    assert_1.assert(requestProps.url && requestProps.method);
    const method = requestProps.method.toUpperCase();
    const urlProps = getUrlProps(requestProps.url);
    assert_1.assert(urlProps.pathname.startsWith("/"));
    const { pathname } = urlProps;
    const { body: requestBody } = requestProps;
    const isHumanMode = isHumanReadableMode(method);
    if (!["GET", "POST"].includes(method) ||
        !pathname.startsWith(config.baseUrl)) {
        return { isNotWildcardRequest: true, isHumanMode };
    }
    const { malformedRequest: malformationError__pathname, endpointName, argsInUrl, } = parsePathname(pathname, config);
    if (malformationError__pathname) {
        return {
            malformedRequest: malformationError__pathname,
            endpointName,
            isHumanMode,
        };
    }
    if (!doesEndpointExist(endpointName, endpoints)) {
        const endpointMissingText = getEndpointMissingText(endpointName, endpoints);
        return {
            malformedRequest: {
                endpointDoesNotExist: true,
                httpBodyErrorText: endpointMissingText.join("\n\n"),
            },
            endpointName,
            isHumanMode,
        };
    }
    const { endpointArgs, malformedRequest, malformedIntegration, } = getEndpointArgs(argsInUrl, requestBody, requestProps, universalAdapterName);
    if (malformedRequest || malformedIntegration) {
        assert_1.assert(!malformedIntegration || !malformedRequest);
        return {
            malformedRequest,
            malformedIntegration,
            endpointName,
            isHumanMode,
        };
    }
    assert_1.assert(endpointArgs && endpointArgs.constructor === Array);
    return {
        endpointArgs,
        endpointName,
        isHumanMode,
    };
}
function getEndpointArgs(argsInUrl, requestBody, requestProps, universalAdapterName) {
    const ARGS_IN_BODY = "args-in-body";
    const args_are_in_body = argsInUrl === ARGS_IN_BODY;
    let endpointArgs__string;
    if (args_are_in_body) {
        if (!requestBody) {
            const malformedIntegration = assert_1.getUsageError([
                universalAdapterName
                    ? `Your ${universalAdapterName} server is not providing the HTTP request body.`
                    : "Argument `body` missing when calling `getApiHttpResponse()`.",
                "You need to provide the HTTP request body when calling an endpoint with arguments serialized to >=2000 characters.",
                getBodyUsageNote(requestProps, universalAdapterName),
            ].join(" "));
            return {
                malformedIntegration,
            };
        }
        const argsInHttpBody = requestBody.constructor === Array
            ? // Server framework already parsed HTTP Request body with JSON
                JSON.stringify(requestBody)
            : // Server framework didn't parse HTTP Request body
                requestBody;
        endpointArgs__string = argsInHttpBody;
    }
    else {
        if (!argsInUrl) {
            return {
                endpointArgs: [],
            };
        }
        endpointArgs__string = argsInUrl;
    }
    assert_1.assert(endpointArgs__string);
    let endpointArgs;
    try {
        endpointArgs = json_s_1.parse(endpointArgs__string);
    }
    catch (err_) {
        const httpBodyErrorText = [
            "Malformatted API request.",
            "Cannot parse `" + endpointArgs__string + "`.",
        ].join(" ");
        return {
            malformedRequest: { httpBodyErrorText },
        };
    }
    if (!endpointArgs || endpointArgs.constructor !== Array) {
        const httpBodyErrorText = "Malformatted API request. The parsed serialized endpoint arguments should be an array.";
        return {
            malformedRequest: { httpBodyErrorText },
        };
    }
    return { endpointArgs };
}
function parsePathname(pathname, config) {
    assert_1.assert(pathname.startsWith(config.baseUrl));
    const urlParts = pathname.slice(config.baseUrl.length).split("/");
    const isMalformatted = urlParts.length < 1 || urlParts.length > 2 || !urlParts[0];
    const endpointName = urlParts[0];
    const argsInUrl = urlParts[1] && decodeURIComponent(urlParts[1]);
    /*
    const pathname__prettified = isMalformatted
      ? pathname
      : config.baseUrl + endpointName + "/" + argsInUrl;
    */
    let malformedRequest;
    if (isMalformatted) {
        malformedRequest = {
            httpBodyErrorText: "Malformatted API URL",
        };
    }
    return {
        malformedRequest,
        endpointName,
        argsInUrl,
    };
}
function handleEndpointOutcome(endpointResult, endpointError, isHumanMode, endpointName, config) {
    let responseProps;
    if (endpointError) {
        responseProps = handleEndpointError(endpointError);
    }
    else {
        responseProps = handleEndpointResult(endpointResult, isHumanMode, endpointName);
    }
    assert_1.assert(responseProps.body.constructor === String);
    if (!config.disableCache) {
        const computeEtag = require("./computeEtag");
        const etag = computeEtag(responseProps.body);
        assert_1.assert(etag);
        responseProps.etag = etag;
    }
    return responseProps;
}
function getEndpointNames(endpoints) {
    return Object.keys(endpoints);
}
function handleInternalError(internalError) {
    const msg = "[Wildcard API][Internal Error] Something unexpected happened. Please open a new issue at https://github.com/reframejs/wildcard-api/issues/new and include this error stack. ";
    internalError = addMessage(internalError, msg);
    console.error(internalError);
    return HttpResponse_serverSideError();
}
function addMessage(err, msg) {
    if (!err) {
        err = new Error();
    }
    if (!err.message || err.message.constructor !== String) {
        err.message = "";
    }
    const prefix = "Error: ";
    if (err.message.startsWith(prefix)) {
        err.message = prefix + msg + err.message.slice(prefix.length);
    }
    else {
        err.message = msg + err.message;
    }
    return err;
}
function handleEndpointError(endpointError) {
    console.error(endpointError);
    return HttpResponse_serverSideError();
}
function handleContextError(contextError) {
    console.error(contextError);
    return HttpResponse_serverSideError();
}
function handleWrongApiUsage(wrongApiUsage) {
    console.error(wrongApiUsage);
    return HttpResponse_serverSideError();
}
function handleMalformedIntegration(malformedIntegration) {
    console.error(malformedIntegration);
    return HttpResponse_serverSideError();
}
function HttpResponse_serverSideError() {
    return {
        body: "Internal Server Error",
        statusCode: 500,
        contentType: "text/plain",
    };
}
function handleMalformedRequest(malformedRequest) {
    // We do NOT print any error on the server-side
    // We only print the malformation error on the browser-side
    // Because it's not a server-side bug but a browser-side bug
    const statusCode = malformedRequest.endpointDoesNotExist ? 404 : 400;
    const { httpBodyErrorText } = malformedRequest;
    return HttpResponse_browserSideError(statusCode, httpBodyErrorText);
}
function HttpResponse_browserSideError(errorCode, httpBodyErrorText) {
    return {
        statusCode: errorCode,
        body: httpBodyErrorText,
        contentType: "text/plain",
    };
}
function handleEndpointResult(endpointResult, isHumanMode, endpointName) {
    let body;
    let endpointError;
    try {
        const ret = json_s_1.stringify(endpointResult);
        body = ret;
    }
    catch (stringifyError) {
        endpointError = assert_1.getUsageError([
            `Couldn't serialize value returned by endpoint \`${endpointName}\`.`,
            "Make sure the returned values",
            "are only of the following types:",
            "`Object`, `string`, `number`, `Date`, `null`, `undefined`, `Inifinity`, `NaN`, `RegExp`.",
        ].join(" "));
    }
    if (endpointError) {
        return handleEndpointError(endpointError);
    }
    if (body === undefined) {
        assert_1.assert(false);
        // Make TS happy
        throw new Error();
    }
    assert_1.assert(body.constructor === String);
    const responseProps = {
        statusCode: 200,
        contentType: "application/json",
        body,
    };
    if (isHumanMode) {
        return makeHumanReadable(responseProps, endpointResult);
    }
    else {
        return responseProps;
    }
}
function validateApiUsage(requestProps, universalAdapterName) {
    try {
        validate();
    }
    catch (wrongApiUsage) {
        return wrongApiUsage;
    }
    return;
    function validate() {
        assert_1.assert((requestProps && requestProps.url && requestProps.method) ||
            !universalAdapterName);
        const missArg = (args) => `Missing argument${args.length === 1 ? "" : "s"} ${args
            .map((s) => "`" + s + "`")
            .join(" and ")} while calling \`getApiHttpResponse()\`.`;
        const missingArguments = [];
        if (!(requestProps === null || requestProps === void 0 ? void 0 : requestProps.url))
            missingArguments.push("url");
        if (!(requestProps === null || requestProps === void 0 ? void 0 : requestProps.method))
            missingArguments.push("method");
        assert_1.assertUsage(missingArguments.length === 0, missArg(missingArguments));
    }
}
function getBodyUsageNote(requestProps, universalAdapterName) {
    const expressNote = "make sure to parse the body, for Express v4.16 and above: `app.use(express.json())`.";
    const koaNote = "make sure to parse the body, for example: `app.use(require('koa-bodyparser')())`.";
    if (universalAdapterName === "express") {
        return "You seem to be using Express; " + expressNote;
    }
    if (universalAdapterName === "koa") {
        return "You seem to be using Koa; " + expressNote;
    }
    if (universalAdapterName === "hapi") {
        assert_1.assert("body" in requestProps);
    }
    return [
        "If you are using Express: " + expressNote,
        "If you are using Hapi: the HTTP request body is available at `request.payload`.",
        "If you are using Koa: " + koaNote,
    ].join(" ");
}
function doesEndpointExist(endpointName, endpoints) {
    const endpoint = endpoints[endpointName];
    return !!endpoint;
}
function noEndpoints(endpoints) {
    const endpointNames = getEndpointNames(endpoints);
    return endpointNames.length === 0;
}
function getEndpointMissingText(endpointName, endpoints) {
    const endpointMissingText = [
        "Endpoint `" + endpointName + "` doesn't exist.",
    ];
    if (noEndpoints(endpoints)) {
        endpointMissingText.push("You didn't define any endpoints.");
    }
    endpointMissingText.push("Make sure that the file that defines `" +
        endpointName +
        "` is named `endpoints.js` or `*.endpoints.js`: Wildcard automatically loads any file with such a name.", "Alternatively, you can manually load your endpoint files: `require('./path/to/file-that-defines-" +
        endpointName +
        ".js')`.");
    return endpointMissingText;
}
function assertNodejs() {
    const isNodejs = typeof "process" !== "undefined" &&
        process &&
        process.versions &&
        process.versions.node;
    assert_1.assertUsage(isNodejs, [
        "You are loading the module `@wildcard-api/server` in the browser.",
        "The module `@wildcard-api/server` is meant for your Node.js server. Load `@wildcard-api/client` instead.",
    ].join(" "));
}
async function getContext(context) {
    if (context === undefined) {
        return undefined;
    }
    const isContextFunction = isCallable(context);
    const contextFunctionName = isContextFunction
        ? getFunctionName(context)
        : null;
    if (isContextFunction) {
        context = await context();
    }
    assertContext(context, isContextFunction, contextFunctionName);
    assert_1.assert(context && context instanceof Object);
    return context;
}
function assertContext(context, isContextFunction, contextFunctionName) {
    if (isContextFunction) {
        const errorMessageBegin = [
            "Your context function",
            ...(!contextFunctionName ? [] : ["`" + contextFunctionName + "`"]),
            "should",
        ].join(" ");
        assert_1.assertUsage(context !== undefined && context !== null, [
            errorMessageBegin,
            "not return `" + context + "`.",
            "If there is no context, then return the empty object `{}`.",
        ].join(" "));
        assert_1.assertUsage(context instanceof Object, [errorMessageBegin, "return a `instanceof Object`."].join(" "));
    }
    assert_1.assertUsage(context && context instanceof Object, [
        "The context cannot be `" + context + "`.",
        "The context should be a `instanceof Object`.",
        "If there is no context then use the empty object `{}`.",
    ].join(" "));
}
function getFunctionName(fn) {
    let { name } = fn;
    if (!name) {
        return name;
    }
    const PREFIX = "bound ";
    if (name.startsWith(PREFIX)) {
        return name.slice(PREFIX.length);
    }
    return name;
}
function loadTimeStuff() {
    // Some infos for `assertUsage` and `assert`
    assert_1.setProjectInfo({
        projectName: "Wildcard API",
        projectGithub: "https://github.com/reframejs/wildcard-api",
    });
    // The Wildcard server only works with Node.js
    assertNodejs();
}
//# sourceMappingURL=WildcardServer.js.map